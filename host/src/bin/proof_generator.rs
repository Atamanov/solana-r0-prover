// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use clap::Parser;
use methods::{GUEST_ELF as METHOD_ELF, GUEST_ID as METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use std::time::Instant;
use twine_solana_r0_prover_lib::{CompleteProofPackage, PublicCommitments};

use twine_solana_r0_prover_host::database::DatabaseClient;

/// CLI arguments for the proof generator
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Starting slot number
    #[arg(short, long)]
    start_slot: u64,

    /// Account public keys to track (comma-separated base58)
    #[arg(short, long, value_delimiter = ',')]
    pubkey: Vec<String>,

    /// Database URL for fetching data
    #[arg(long)]
    db_url: String,

    /// Output file for the proof package
    #[arg(short, long, default_value = "proof_package.json")]
    output: String,

    /// Generate proof (if not set, only validates)
    #[arg(long)]
    prove: bool,

    /// Maximum number of account change rows to include; if exceeded, end_slot is pulled earlier
    #[arg(long, default_value_t = 10000)]
    max_account_changes: usize,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();
    let args = Args::parse();

    println!("🚀 Starting Twine Solana R0 Prover");
    println!("📊 Configuration:");
    println!("  📍 Start slot: {}", args.start_slot);
    println!("  🔑 Accounts: {}", args.pubkey.join(","));
    println!("  🗄️  Database: {}", args.db_url);

    let mut monitored_accounts: Vec<[u8; 32]> = Vec::new();
    for pk in &args.pubkey {
        let bytes = bs58::decode(pk).into_vec()?;
        if bytes.len() != 32 {
            return Err("Invalid pubkey length".into());
        }
        let mut arr = [0u8; 32];
        arr.copy_from_slice(&bytes);
        monitored_accounts.push(arr);
    }

    // Connect to database and fetch data
    println!("📡 Connecting to database...");
    let db_client = DatabaseClient::new(&args.db_url).await?;

    println!("📥 Fetching proof data from database...");
    let complete_proof_package = db_client
        .fetch_proof_package(args.start_slot, monitored_accounts)
        .await?;

    println!("\n✅ Complete proof package generated successfully!");
    println!("📈 Summary:");
    println!("  🎯 Start slot: {}", complete_proof_package.start_slot);
    println!("  🏁 End slot: {}", complete_proof_package.end_slot);
    println!(
        "  📊 Slot chain length: {}",
        complete_proof_package.slot_chain.len()
    );
    println!(
        "  📊 Account changes: {}",
        complete_proof_package.account_changes.len()
    );
    println!(
        "  📊 Vote transactions: {}",
        complete_proof_package.vote_transactions.len()
    );

    // Save debug package
    let debug_package = DebugProofPackage {
        start_slot: complete_proof_package.start_slot,
        end_slot: complete_proof_package.end_slot,
        account_pubkeys: args.pubkey.clone(),
        slot_chain_length: complete_proof_package.slot_chain.len(),
        account_changes_count: complete_proof_package.account_changes.len(),
        vote_transactions_count: complete_proof_package.vote_transactions.len(),
    };

    let json = serde_json::to_string_pretty(&debug_package)?;
    std::fs::write(&args.output, json)?;

    // Generate proof if requested
    if args.prove {
        println!("\n🔐 Generating complete ZK proof with full cryptographic verification...");
        let proof_start = Instant::now();
        let (receipt, commitments) = generate_complete_zk_proof(&complete_proof_package)?;
        let proof_duration = proof_start.elapsed();
        println!("⏱️  Proof generated in: {:.2?}", proof_duration);

        println!("Public Commitments:");
        println!("  Start slot: {}", commitments.start_slot);
        println!("  End slot: {}", commitments.end_slot);
        println!("  Epoch: {}", commitments.epoch);
        println!("  Validations passed: {}", commitments.validations_passed);

        // Verify the receipt
        receipt.verify(METHOD_ID).unwrap();
        println!("Proof verified successfully!");
    } else {
        println!("\n✅ Proof package ready. Use --prove to generate ZK proof.");
    }

    println!("\n📦 Complete proof package saved to: {}", args.output);
    Ok(())
}

/// Generate ZK proof with full cryptographic verification using RISC Zero
fn generate_complete_zk_proof(
    proof_package: &CompleteProofPackage,
) -> Result<(risc0_zkvm::Receipt, PublicCommitments), Box<dyn std::error::Error>> {
    // Create executor environment with the proof package as input
    let env = ExecutorEnv::builder()
        .write(&proof_package)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover
    let prover = default_prover();

    println!("Generating proof...");

    // Generate proof by running the guest program
    let prove_info = prover.prove(env, METHOD_ELF).unwrap();

    // Extract the receipt
    let receipt = prove_info.receipt;

    // Decode the public commitments from the journal
    let commitments: PublicCommitments = receipt.journal.decode().unwrap();

    Ok((receipt, commitments))
}

/// Debug proof package structure (for JSON output)
#[derive(Debug, Serialize, Deserialize)]
struct DebugProofPackage {
    start_slot: u64,
    end_slot: u64,
    account_pubkeys: Vec<String>,
    slot_chain_length: usize,
    account_changes_count: usize,
    vote_transactions_count: usize,
}
