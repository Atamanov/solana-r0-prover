// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use blake3::Hasher as Blake3Hasher;
use clap::Parser;
use ed25519_dalek::{Signature, VerifyingKey, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH};
use methods::{GUEST_ELF as METHOD_ELF, GUEST_ID as METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use std::time::Instant;
use twine_solana_r0_prover_lib::{
    CompleteProofPackage, PublicCommitments, ZkSlotData, ZkValidatorSetEntry, ZkVoteTransaction,
};

use twine_solana_r0_prover_host::database::DatabaseClient;

/// CLI arguments for the proof generator
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Starting slot number
    #[arg(short, long)]
    start_slot: u64,

    /// Account public keys to track (comma-separated base58)
    #[arg(short, long, value_delimiter = ',')]
    pubkey: Vec<String>,

    /// Database URL for fetching data (ignored if --input-json is specified)
    #[arg(long)]
    db_url: Option<String>,

    /// Output file for the proof package
    #[arg(short, long, default_value = "proof_package.json")]
    output: String,

    /// Generate proof (if not set, only validates)
    #[arg(long)]
    prove: bool,

    /// Maximum number of account change rows to include; if exceeded, end_slot is pulled earlier
    #[arg(long, default_value_t = 10000)]
    max_account_changes: usize,

    /// Dump database input to JSON file and exit (no proof generation)
    #[arg(long)]
    dump_json: Option<String>,

    /// Read input from JSON file instead of database
    #[arg(long)]
    input_json: Option<String>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();
    let args = Args::parse();

    println!("🚀 Starting Twine Solana R0 Prover");

    // Parse monitored accounts
    let mut monitored_accounts: Vec<[u8; 32]> = Vec::new();
    for pk in &args.pubkey {
        let bytes = bs58::decode(pk).into_vec()?;
        if bytes.len() != 32 {
            return Err("Invalid pubkey length".into());
        }
        let mut arr = [0u8; 32];
        arr.copy_from_slice(&bytes);
        monitored_accounts.push(arr);
    }

    // Get complete proof package from database or JSON file
    let complete_proof_package = if let Some(input_json) = &args.input_json {
        // Read from JSON file
        println!("📄 Reading input from JSON file: {}", input_json);
        read_proof_package_from_json(input_json)?
    } else {
        // Fetch from database
        let db_url = args
            .db_url
            .as_ref()
            .ok_or("Database URL required when not using --input-json")?;

        println!("📊 Configuration:");
        println!("  📍 Start slot: {}", args.start_slot);
        println!("  🔑 Accounts: {}", args.pubkey.join(","));
        println!("  🗄️  Database: {}", db_url);

        println!("📡 Connecting to database...");
        let db_client = DatabaseClient::new(db_url).await?;

        println!("📥 Fetching proof data from database...");
        let package = db_client
            .fetch_proof_package(args.start_slot, monitored_accounts)
            .await?;

        // If dump_json is specified, save to JSON and exit
        if let Some(dump_path) = &args.dump_json {
            println!("💾 Dumping database input to JSON file: {}", dump_path);
            dump_proof_package_to_json(&package, dump_path)?;
            println!("✅ Database input dumped to: {}", dump_path);
            return Ok(());
        }

        package
    };

    println!("\n✅ Complete proof package generated successfully!");
    println!("📈 Summary:");
    println!("  🎯 Start slot: {}", complete_proof_package.start_slot);
    println!("  🏁 End slot: {}", complete_proof_package.end_slot);
    println!(
        "  📊 Slot chain length: {}",
        complete_proof_package.slot_chain.len()
    );
    println!(
        "  📊 Account changes: {}",
        complete_proof_package.account_changes.len()
    );
    println!(
        "  📊 Vote transactions: {}",
        complete_proof_package.vote_transactions.len()
    );

    // Save debug package
    let debug_package = DebugProofPackage {
        start_slot: complete_proof_package.start_slot,
        end_slot: complete_proof_package.end_slot,
        account_pubkeys: args.pubkey.clone(),
        slot_chain_length: complete_proof_package.slot_chain.len(),
        account_changes_count: complete_proof_package.account_changes.len(),
        vote_transactions_count: complete_proof_package.vote_transactions.len(),
    };

    let json = serde_json::to_string_pretty(&debug_package)?;
    std::fs::write(&args.output, json)?;

    // Validate the proof package before generating proof
    println!("\n🔍 Validating proof package...");
    if let Err(e) = validate_proof_package(&complete_proof_package) {
        return Err(format!("Proof package validation failed: {}", e).into());
    }
    println!("✅ Proof package validation passed");

    // Generate proof if requested
    if args.prove {
        println!("\n🔐 Generating complete ZK proof with full cryptographic verification...");
        let proof_start = Instant::now();
        let (receipt, commitments) = generate_complete_zk_proof(&complete_proof_package)?;
        let proof_duration = proof_start.elapsed();
        println!("⏱️  Proof generated in: {:.2?}", proof_duration);

        println!("Public Commitments:");
        println!("  Start slot: {}", commitments.start_slot);
        println!("  End slot: {}", commitments.end_slot);
        println!("  Epoch: {}", commitments.epoch);
        println!("  Validations passed: {}", commitments.validations_passed);

        // Verify the receipt
        receipt.verify(METHOD_ID).unwrap();
        println!("Proof verified successfully!");
    } else {
        println!("\n✅ Proof package ready. Use --prove to generate ZK proof.");
    }

    println!("\n📦 Complete proof package saved to: {}", args.output);
    Ok(())
}

/// Generate ZK proof with full cryptographic verification using RISC Zero
fn generate_complete_zk_proof(
    proof_package: &CompleteProofPackage,
) -> Result<(risc0_zkvm::Receipt, PublicCommitments), Box<dyn std::error::Error>> {
    // Create executor environment with the proof package as input
    let env = ExecutorEnv::builder()
        .write(&proof_package)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover
    let prover = default_prover();

    println!("Generating proof...");

    // Generate proof by running the guest program
    let prove_info = prover.prove(env, METHOD_ELF).unwrap();

    // Extract the receipt
    let receipt = prove_info.receipt;

    // Decode the public commitments from the journal
    let commitments: PublicCommitments = receipt.journal.decode().unwrap();

    Ok((receipt, commitments))
}

/// Debug proof package structure (for JSON output)
#[derive(Debug, Serialize, Deserialize)]
struct DebugProofPackage {
    start_slot: u64,
    end_slot: u64,
    account_pubkeys: Vec<String>,
    slot_chain_length: usize,
    account_changes_count: usize,
    vote_transactions_count: usize,
}

/// Validate the proof package before sending to zkVM
fn validate_proof_package(pkg: &CompleteProofPackage) -> Result<(), String> {
    // Basic checks
    if pkg.slot_chain.is_empty() {
        return Err("slot_chain cannot be empty".to_string());
    }
    if pkg.start_slot >= pkg.end_slot {
        return Err("start_slot must be less than end_slot".to_string());
    }

    // Chain continuity check
    if !verify_chain_continuity(&pkg.slot_chain) {
        return Err("chain continuity verification failed".to_string());
    }

    // Vote verification (ESR inclusion, signatures, supermajority)
    if let Some(last_slot) = pkg.slot_chain.last() {
        if !verify_votes_intent_signatures_esr_and_supermajority(
            &pkg.vote_transactions,
            &pkg.validator_set,
            &pkg.esr_data,
            &pkg.merkle_proofs,
            last_slot,
        ) {
            return Err("vote verification (ESR/signatures/supermajority) failed".to_string());
        }
    } else {
        return Err("slot_chain must contain at least one slot".to_string());
    }

    Ok(())
}

fn verify_chain_continuity(slot_chain: &[ZkSlotData]) -> bool {
    for i in 1..slot_chain.len() {
        let prev = &slot_chain[i - 1];
        let curr = &slot_chain[i];
        if curr.slot != prev.slot + 1 {
            eprintln!(
                "Non-consecutive slots: prev_slot={}, curr_slot={}",
                prev.slot, curr.slot
            );
            return false;
        }
        if curr.parent_bank_hash != prev.bank_hash {
            eprintln!(
                "Bank hash chain broken at slot {}: parent_bank_hash != prev_bank_hash",
                curr.slot
            );
            return false;
        }
    }
    true
}

fn verify_votes_intent_signatures_esr_and_supermajority(
    votes: &[ZkVoteTransaction],
    validators: &[ZkValidatorSetEntry],
    esr: &Option<twine_solana_r0_prover_lib::ZkEpochValidatorMerkleRoot>,
    proofs: &std::collections::HashMap<[u8; 32], Vec<[u8; 32]>>,
    last_slot: &ZkSlotData,
) -> bool {
    if esr.is_none() {
        eprintln!("missing ESR data");
        return false;
    }
    if votes.is_empty() {
        eprintln!("no vote transactions for slot {}", last_slot.slot);
        return false;
    }

    let mut sorted = validators.to_vec();
    sorted.sort_by(|a, b| a.validator_vote_account.cmp(&b.validator_vote_account));
    let mut vmap = std::collections::HashMap::new();
    for (idx, v) in sorted.iter().enumerate() {
        vmap.insert(v.validator_vote_account, (idx, v.active_stake));
    }

    let mut unique_validators: std::collections::HashSet<[u8; 32]> =
        std::collections::HashSet::new();
    let mut voting_stake: u128 = 0;
    let mut ok = true;

    // Track statistics for debugging
    let mut votes_with_matching_hash = 0;
    let mut votes_with_mismatched_hash = 0;
    let mut total_votes_processed = 0;

    for vt in votes {
        total_votes_processed += 1;

        // Votes should already be filtered to only those voting for the target slot
        // Double-check to ensure data consistency
        if !vt.vote_slots.iter().any(|&s| s == last_slot.slot) {
            eprintln!(
                "WARNING: Vote in database doesn't include target slot {}",
                last_slot.slot
            );
            // Skip this vote but don't fail the entire verification
            continue;
        }

        // Filter out votes that don't match the bank hash
        // This is expected behavior - not all votes will have the same hash
        match vt.vote_hash {
            Some(h) if h == last_slot.bank_hash => {
                votes_with_matching_hash += 1;
            }
            _ => {
                // This is normal - votes can have different hashes
                // Just skip this vote, don't fail verification
                votes_with_mismatched_hash += 1;
                continue;
            }
        }

        // Verify signatures against message
        let tx = &vt.vote_transaction;
        if tx.len() < 65 {
            eprintln!("tx too short for vote at slot {}", vt.slot);
            ok = false;
            continue;
        }
        let (sig_count, sigs_offset) = parse_compact_u16(tx);
        if sig_count == 0 {
            eprintln!("no signatures in vote at slot {}", vt.slot);
            ok = false;
            continue;
        }
        let msg_start = sigs_offset + (sig_count as usize * SIGNATURE_LENGTH);
        if msg_start >= tx.len() {
            eprintln!("invalid tx structure at slot {}", vt.slot);
            ok = false;
            continue;
        }
        let message = &tx[msg_start..];

        let pairs = core::cmp::min(sig_count as usize, vt.signer_pubkeys.len());
        let mut sigs_ok = true;
        for i in 0..pairs {
            let start = sigs_offset + (i * SIGNATURE_LENGTH);
            let end = start + SIGNATURE_LENGTH;
            if end > tx.len() {
                sigs_ok = false;
                break;
            }
            let mut sig_bytes = [0u8; SIGNATURE_LENGTH];
            sig_bytes.copy_from_slice(&tx[start..end]);
            let sig = Signature::from_bytes(&sig_bytes);
            let mut pk = [0u8; PUBLIC_KEY_LENGTH];
            pk.copy_from_slice(&vt.signer_pubkeys[i]);
            let vk = match VerifyingKey::from_bytes(&pk) {
                Ok(v) => v,
                Err(_) => {
                    sigs_ok = false;
                    break;
                }
            };
            if vk.verify_strict(message, &sig).is_err() {
                sigs_ok = false;
                break;
            }
        }
        if !sigs_ok {
            eprintln!("invalid signature set for vote at slot {}", vt.slot);
            ok = false;
            continue;
        }

        if let Some(av) = vt.authorized_voter {
            if !vt.signer_pubkeys.iter().any(|pk| pk == &av) {
                eprintln!("authorized voter not among signers");
                ok = false;
                continue;
            }
        }

        // ESR inclusion using provided merkle proof
        let vote_acct = vt.vote_account_pubkey;
        let (leaf_index, active_stake) = match vmap.get(&vote_acct) {
            Some(x) => *x,
            None => {
                // Not in top-N set; skip stake accumulation
                continue;
            }
        };
        let proof = match proofs.get(&vote_acct) {
            Some(p) => p,
            None => {
                eprintln!(
                    "missing ESR merkle proof for vote account {}",
                    bs58::encode(&vote_acct).into_string()
                );
                ok = false;
                continue;
            }
        };
        if !verify_vote_merkle_proof(
            &vote_acct,
            active_stake,
            proof,
            &esr.as_ref().unwrap().merkle_root,
            leaf_index,
        ) {
            eprintln!(
                "ESR merkle proof failed for vote account {}",
                bs58::encode(&vote_acct).into_string()
            );
            ok = false;
            continue;
        }

        if unique_validators.insert(vote_acct) {
            voting_stake += active_stake as u128;
        }
    }

    // Log vote processing statistics
    eprintln!(
        "Vote processing for slot {}: total_votes={}, matching_hash={}, mismatched_hash={}",
        last_slot.slot, total_votes_processed, votes_with_matching_hash, votes_with_mismatched_hash
    );

    if !ok {
        eprintln!("Vote verification failed due to signature or other validation errors");
        return false;
    }

    let total = esr.as_ref().unwrap().total_active_stake as u128;
    let supermajority = voting_stake * 3 >= total * 2;

    // Enhanced logging for consensus status
    let percentage = if total > 0 {
        (voting_stake * 100) / total
    } else {
        0
    };
    eprintln!(
        "Consensus check for slot {}: voting_stake={} ({}%), total_stake={}, required=66.67%",
        last_slot.slot, voting_stake, percentage, total
    );

    if !supermajority {
        eprintln!(
            "❌ Supermajority NOT reached for slot {} - only {}% of stake voted with matching hash",
            last_slot.slot, percentage
        );
        eprintln!(
            "   Need at least {} stake, but only have {} stake from {} validators with matching bank hash",
            (total * 2) / 3, voting_stake, unique_validators.len()
        );
    } else {
        eprintln!(
            "✅ Supermajority reached for slot {} - {}% of stake voted with matching hash",
            last_slot.slot, percentage
        );
    }

    supermajority
}

fn parse_compact_u16(bytes: &[u8]) -> (u16, usize) {
    if bytes.is_empty() {
        return (0, 0);
    }

    match bytes[0] {
        0..=127 => (bytes[0] as u16, 1),
        128..=255 if bytes.len() >= 3 => {
            let val = (bytes[1] as u16) | ((bytes[2] as u16) << 8);
            (val, 3)
        }
        _ => (0, 1),
    }
}

fn verify_vote_merkle_proof(
    vote_account: &[u8; 32],
    active_stake: u64,
    proof: &[[u8; 32]],
    merkle_root: &[u8; 32],
    mut leaf_index: usize,
) -> bool {
    // Leaf hash: Blake3(vote_account || count(1) || vote_account || stake || total_stake)
    let mut h = Blake3Hasher::new();
    h.update(vote_account);
    h.update(&(1u32).to_le_bytes());
    h.update(vote_account);
    h.update(&active_stake.to_le_bytes());
    h.update(&active_stake.to_le_bytes());
    let mut current = *h.finalize().as_bytes();

    for sib in proof {
        let mut hh = Blake3Hasher::new();
        if leaf_index % 2 == 0 {
            hh.update(&current);
            hh.update(sib);
        } else {
            hh.update(sib);
            hh.update(&current);
        }
        current = *hh.finalize().as_bytes();
        leaf_index /= 2;
    }
    current == *merkle_root
}

/// Dump proof package to JSON file
fn dump_proof_package_to_json(
    package: &CompleteProofPackage,
    file_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let json = serde_json::to_string_pretty(package)?;
    std::fs::write(file_path, json)?;
    Ok(())
}

/// Read proof package from JSON file
fn read_proof_package_from_json(
    file_path: &str,
) -> Result<CompleteProofPackage, Box<dyn std::error::Error>> {
    let json = std::fs::read_to_string(file_path)?;
    let package: CompleteProofPackage = serde_json::from_str(&json)?;
    Ok(package)
}
